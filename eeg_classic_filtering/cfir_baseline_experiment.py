import argparse
import typing as tp
import numpy as np
from optuna.study import Study
from tqdm import tqdm
from eeg_classic_filtering.cfir_filter import CFIRBandDetector
from eeg_classic_filtering.datasets import NPWrapperDataset
from eeg_classic_filtering.helpful_functions import calculate_metrics, save_results
from eeg_classic_filtering.hyperparameters_optimization import optimize_and_test_real, optimize_and_test_synthetic
from general_utilities.utils import make_deterministic


def test_cfir_filter(cfir_band: tuple[float, float], cfir_n_taps: int, cfir_n_fft: int, sampling_rate: float,
                     dataset: NPWrapperDataset, dataset_type: str, dataset_name: str,
                     frequency: tp.Optional[float], filter_band: tp.Optional[tuple[float, float]],
                     noise_coeff: tp.Optional[float], model_name: tp.Optional[str],
                     save: bool = True):
    """
    Runs a single test for a specific hyperparameters of the cFIR filter tuned to perform at lag of 0 ms,
    calculates metrics and can save results. Note, cFIR will not have a true lag of 0 ms. It tries to approximate an
    FIR filter and stay within the requested lag and usually improves the real delay. However, typically it's true
    delay is still far from 0 ms

    Parameters
    ----------
    cfir_band : tuple (freq_low, freq_high)
                A cutoff of the ideal FIR filter that cFIR has to approximate
    cfir_n_taps : int
                Number of taps of the ideal FIR filter
    cfir_n_fft : int
                Length of an ideal FIR filter
    sampling_rate : float
                Sampling rate of the data
    dataset : NPWrapperDataset
                Dataset instance on which function will test cFIR
    dataset_type : str
                Type of the dataset. Will be only used for writing to json with results as a hint
    dataset_name : str
                Name of the dataset. One of ['sines_white', 'sines_pink', 'state_space_white', 'state_space_pink',
                'filtered_pink', 'multiperson_real_data']. Will be only used for writing to json with results as a hint
    frequency : float
                Central frequency for the dataset. Will be only used for writing to json with results as a hint.
                Suggested to use None if dataset is filtered_pink (relies on filter_band, not central frequency during
                generation) or multiperson_real_data (ground truth central frequency is unknown)
    filter_band : tuple (freq_low, freq_high)
                Use only for filtered_pink dataset. This dataset is generated by adding a sample of pink noise to
                another sample of pink noise filtered in the filter_band. For others use None.
                Will be only used for writing to json with results as a hint
    noise_coeff : float
                Noise coefficient by which a sample of noise is amplified. Used to calculate Noise Level.
                Use None for multiperson_real_data as here the noise comes from the data rather that being added during
                generation. Will be only used for writing to json with results as a hint
    model_name : str
                Name of the model to write to appropriate model folder in the results directory. Your path to saved
                results will be results/test_results/model_name/YYYY-MM-DD/00-00-00
    save : bool
                Whether to save the results or not

    Returns
    -------
    detailed_errors_dict : dict
                Dictionary which has lists of error for appropriate metrics
                ['correlation', 'plv', 'circstd', 'circstd_degrees']
    predictions : dict
                Dictionary with predictions for the dataset (observations filtered with cFIR tuned to lag 0 ms). It has
                keys 'complex_pred', 'complex_gt' for aligned filtration results and ground truth respectively. It also
                has keys 'envelope_pred' and 'envelope_gt' for their respective envelopes
    """
    assert dataset_name in ['sines_white', 'sines_pink', 'state_space_white', 'state_space_pink', 'filtered_pink',
                            'multiperson_real_data']
    cfir = CFIRBandDetector(delay=0,
                            band=cfir_band,
                            sampling_rate=sampling_rate,
                            n_taps=cfir_n_taps,
                            n_fft=cfir_n_fft,
                            weights=None)
    ds_size = dataset.get_size()
    output_size = dataset.output_size
    filtered_series = []
    gt_series = []
    for idx in tqdm(range(ds_size)):
        datapoint_X, gt_y = dataset.get_datapoint(idx)
        assert len(datapoint_X.shape) == 1
        assert len(gt_y.shape) == 1
        filtered_X = cfir.filter_data(datapoint_X)
        filtered_X = filtered_X[-output_size:]
        filtered_series.append(filtered_X)
        gt_series.append(gt_y)
    filtered_series = np.array(filtered_series)
    gt_series = np.array(gt_series)
    assert filtered_series.shape == gt_series.shape

    detailed_errors_dict, aggregated, predictions = calculate_metrics(complex_pred=filtered_series,
                                                                      complex_gt=gt_series)

    print(dataset_name)
    for metric, agg in aggregated.items():
        print(metric, agg)
    print('\n')

    if save:

        save_results(detailed_errors_dict=detailed_errors_dict,
                     predictions=predictions, dataset_type=dataset_type, dataset_name=dataset_name,
                     frequency=frequency, filter_band=filter_band, sampling_rate=sampling_rate,
                     noise_coeff=noise_coeff, model_name=model_name,
                     model_params={'cfir_band': cfir_band, 'cfir_n_taps': cfir_n_taps, 'cfir_n_fft': cfir_n_fft})

    return detailed_errors_dict, predictions


def optuna_cfir_objective(trial: Study, metric_name: str, sampling_rate: float,
                          dataset: NPWrapperDataset,
                          dataset_type: str, dataset_name: str):
    """
    Objective function for the optuna framework to fit cFIR hyperparameters

    Parameters
    ----------
    trial: Study
                Optuna Study instance. Typically, is created with optuna.create_study(direction=direction), where
                direction is maximize or minimize.
    metric_name : str
                One of ['correlation', 'plv', 'circstd', 'circstd_degrees']. Choose metric according to which cFIR
                hyperparameters will be optimized
    sampling_rate : float
                Sampling rate of the data
    dataset : NPWrapperDataset
                Dataset instance on which function will test cFIR
    dataset_type : str
                Type of the dataset
    dataset_name : str
                Name of the dataset. One of ['sines_white', 'sines_pink', 'state_space_white', 'state_space_pink',
                'filtered_pink', 'multiperson_real_data']

    Returns
    -------
    mean_error : float
                Mean value of the metric_name over dataset
    """
    band_low = trial.suggest_float('cfir_band_low', 7, 9.5)
    band_high = trial.suggest_float('cfir_band_high', 9.6, 15)
    cfir_n_taps = trial.suggest_int('cfir_n_taps', 100, 1000, 50)
    cfir_n_fft = trial.suggest_int('cfir_n_fft', 1000, 3000, 100)
    cfir_band = (band_low, band_high)
    detailed_errors_dict, predictions = test_cfir_filter(cfir_band=cfir_band,
                                                         cfir_n_taps=cfir_n_taps,
                                                         cfir_n_fft=cfir_n_fft,
                                                         sampling_rate=sampling_rate,
                                                         dataset=dataset,
                                                         dataset_type=dataset_type,
                                                         dataset_name=dataset_name,
                                                         frequency=None, filter_band=None,
                                                         noise_coeff=None, model_name=None,
                                                         save=False)

    return np.mean(detailed_errors_dict[metric_name])


def optuna_cfir_parameters_restructurer(parameters: dict):
    """
    It is convenient to pass cFIR band parameter to optuna as two floats cfir_band_low and cfir_band_high.
    Therefore, fitted parameters will be in the same format. This function will change separate cfir_band_low and
    cfir_band_high to a cutoff tuple cfir_band = (cfir_band_low, cfir_band_high) for convenience

    Parameters
    ----------
    parameters : dict
                Dictionary with cFIR parameters

    Returns
    -------
    new_parameters : dict
                Dictionary with cFIR parameters with substituted cfir_band_low and cfir_band_high for cfir_band
    """
    cfir_band_low = parameters['cfir_band_low']
    cfir_band_high = parameters['cfir_band_high']
    cfir_band = (cfir_band_low, cfir_band_high)
    del parameters['cfir_band_low']
    del parameters['cfir_band_high']
    parameters['cfir_band'] = cfir_band
    return parameters


def optimize_and_test_cfir_baseline(dataset_name: str, dataset_path: str):
    """
    General function for tuning cFIR for dataset_name on the train split, testing on the generated test split and
    saving results.

    Parameters
    ----------
    dataset_name : str
                Name of the dataset. One of ['sines_white', 'sines_pink', 'state_space_white', 'state_space_pink',
                'filtered_pink', 'multiperson_real_data']
    dataset_path : str
                Path to the train_split of the dataset in case of 'sines_white', 'sines_pink', 'filtered_pink',
                'state_space_white', 'state_space_pink' (test split will be generated) or to the whole real dataset
                (will be split into train and test)
    """

    if dataset_name in ['sines_white', 'sines_pink', 'filtered_pink', 'state_space_white', 'state_space_pink']:

        optimize_and_test_synthetic(model_name='cFIR',
                                    optuna_objective=optuna_cfir_objective,
                                    optuna_parameters_restructurer=optuna_cfir_parameters_restructurer,
                                    dataset_name=dataset_name, train_dataset_path=dataset_path,
                                    add_X_dimension=False, test_function=test_cfir_filter,
                                    n_trials=100, train_amount_of_observations=4500)

    elif dataset_name == 'multiperson_real_data':

        optimize_and_test_real(model_name='cFIR',
                               optuna_objective=optuna_cfir_objective,
                               optuna_parameters_restructurer=optuna_cfir_parameters_restructurer,
                               dataset_path=dataset_path,
                               add_X_dimension=False, test_function=test_cfir_filter,
                               n_trials=100)

    else:
        raise ValueError('dataset_name is not recognized. Please choose one from the following list of synthetic '
                         'datasets: [sines_white, sines_pink, filtered_pink, state_space_white, state_space_pink] or '
                         'a multiperson_real_data for real dataset.')


if __name__ == '__main__':
    make_deterministic(seed=0)
    parser = argparse.ArgumentParser(description='Optimizing hyperparameters and testing cFIR model '
                                                 'on a synthetic generated or real multi-person dataset.')
    parser.add_argument('-n', '--dataset_name', type=str,
                        choices=['sines_white', 'sines_pink', 'state_space_white', 'state_space_pink', 'filtered_pink',
                                 'multiperson_real_data'],
                        help='Name of the required dataset for generation', required=True)
    parser.add_argument('-t', '--dataset_path', type=str,
                        help='Path to the dataset from the current working directory. '
                             'Will be used for finding hyperparameters on synthetic dataset and '
                             'for optimizing hyperparameters and testing for multi-person real dataset', required=True)
    args = parser.parse_args()
    optimize_and_test_cfir_baseline(dataset_name=args.dataset_name, dataset_path=args.dataset_path)
